package service

import (
	"context"
	"time"

	"github.com/hfleury/bk_globalshot/internal/model"
	"github.com/hfleury/bk_globalshot/internal/repository"
)

type CompanyService interface {
	CreateCompany(ctx context.Context, name string) (*model.Company, error)
	GetAllCompanies(ctx context.Context, limit, offset int) ([]*model.Company, int64, error)
	GetCompanyByID(ctx context.Context, id string) (*model.Company, error)
	UpdateCompany(ctx context.Context, id string, name string) (*model.Company, error)
	DeleteCompany(ctx context.Context, id string) error
}

type companyService struct {
	repo repository.CompanyRepository
}

func NewCompanyService(repo repository.CompanyRepository) CompanyService {
	return &companyService{repo: repo}
}

func (s *companyService) CreateCompany(ctx context.Context, name string) (*model.Company, error) {
	company := &model.Company{
		// ID is generated by DB default uuid_generate_v4()
		Name:      name,
		CreatedAt: time.Now(),
	}
	// Note: If we rely on DB for ID, we might need to change repository to Scan the ID back after insert (RETURNING id).
	// Let's assume standard UUID generation by DB for now, but if we need the ID immediately, we should update repo.
	// Actually, common practice with UUID in psql:
	// Either generate primarily in Go, OR generate in DB and use RETURNING.
	// My previous repo impl used `INSERT ... VALUES ...` without returning.
	// Ideally I should update Repo to use `INSERT ... RETURNING id` or generate UUID here.
	// Let's generate UUID here for simplicity if we had a generator, but using DB default is better.
	// Update: I will check repo again. It passes `company.ID`.
	// If I pass empty string, and DB expects UUID, it might fail if I try to insert empty string into UUID column?
	// No, empty string passed to Exec for UUID column is invalid syntax usually unless using a driver that handles it.
	// Better strategy: Let DB handle it by NOT inserting ID, or using DEFAULT.
	// Let's update Repo to use `DEFAULT` or generate UUID in Go.
	// For now, I'll update the Service to just pass the struct, but I probably need to fix Repo to handle ID generation properly.
	// Let's assume I will fix Repo to use `RETURNING` ID.

	// Correction: My repo implementation was:
	// INSERT INTO companies (id, name, created_at) VALUES ($1, $2, $3)
	// This expects ME to provide the ID.
	// I should generate the UUID in Go then.
	// Or change query to `INSERT INTO companies (name, created_at) VALUES ($1, $2) RETURNING id`.
	// Since I don't want to add a UUID library dependency just yet if not needed (though I likely have google/uuid or similar),
	// I will modify the REPO to use DB generation.

	return company, s.repo.Create(ctx, company)
}

func (s *companyService) GetAllCompanies(ctx context.Context, limit, offset int) ([]*model.Company, int64, error) {
	return s.repo.FindAll(ctx, limit, offset)
}

func (s *companyService) GetCompanyByID(ctx context.Context, id string) (*model.Company, error) {
	return s.repo.FindByID(ctx, id)
}

func (s *companyService) UpdateCompany(ctx context.Context, id string, name string) (*model.Company, error) {
	company, err := s.repo.FindByID(ctx, id)
	if err != nil {
		return nil, err
	}
	if company == nil {
		return nil, nil // Or explicit error not found
	}

	company.Name = name
	// company.UpdatedAt = time.Now() // If we had this field

	if err := s.repo.Update(ctx, company); err != nil {
		return nil, err
	}
	return company, nil
}

func (s *companyService) DeleteCompany(ctx context.Context, id string) error {
	company, err := s.repo.FindByID(ctx, id)
	if err != nil {
		return err
	}
	if company == nil {
		return nil // Or error not found
	}
	return s.repo.Delete(ctx, id)
}
